---
layout: post
title: 春节假期学习簿之Groovy学习笔记之语法浅析
subtitle: 一个好的程序员，并不是因为他会某一门热门的编程语言，而是因为，他是个能解决问题的工程师。
header-img: http://ww3.sinaimg.cn/large/51d3f408gw1eqrkeb03pkj21hc0u0jwp.jpg
---

这个春节过得很充实，因为学习了Groovy。“了”字用得不对，因为还在学习中。趁翔还是热得，稍做些总结。古人有云，学而时习之，不亦乐乎嘛。

### Groovy与Java
如果你想要学好Groovy，你首先得是一位有经验的Java程序员。Groovy是Java程序员的出路（之一）。单独来看的话，太小众。

Groovy比Java更动态，更偏向于函数化。它支持不可变对象和闭包，但同时又没有抛弃指令式编程。它不强制你使用何种风格，所以选择权在你手上。因此，个人觉得，它更像Java程序员的出路，而不是一门独立的函数化编程语言。

### 动态类型与多路分发

与Java不同，Groovy是动态的。说它是动态的，是因为它是运行期多路分发/多宗绑定/多分派的（[Multiple Dispatch/Multimethods](https://en.wikipedia.org/wiki/Multiple_dispatch) 下文称多宗绑定）。

所谓多宗绑定既：[注1](#id1)

* 方法的接收者与方法的参数统称为宗量。
* 根据分派基于多少种宗量，将分派划分为单分派和多分派两种。
* 多分派（多宗绑定）既基于多种宗量对目标方法进行选择。
* Java是，编译期多分派，运行期单分派的。

我知道你看不懂，来来来，我们来看几段代码：

{% highlight groovy %}
def var1 = 'Some String'
{% endhighlight %}

等同于Java中的
{% highlight java %}
Object var1 = "Some String"
{% endhighlight %}

但是，如果你在Java中
{% highlight java %}
class Test1 {

  public void someMethod(String value) {
    // process with String value...
    System.out.println("someMethod with string param");
  }
  public void someMethod(Object value) {
    // process with Object value ...
    System.out.println("someMethod with object param");
  }

  public static void main(String[] args) {
    Object var1 = "Hello World!";
    new Test1().someMethod(var1);

    String var2 = "Hello World2!";
    new Test1().someMethod(var2);
  }
}
{% endhighlight %}

资深Java程序员会这样告诉你

    someMethod with object param
    someMethod with string param


但如果你在Groovy中做同样的事情的话
{% highlight groovy %}
def someMethod(String value) {
  // process ...
  println("someMethod with string param")
}

def someMethod(Object value) {
  // process ...
  println("someMethod with object param")
}

def var1 = "Hello World"
someMethod(var1)

String var2 = "hello world2"
someMethod(var2)
{% endhighlight %}

你会得到这样的结果


    someMethod with string param
    someMethod with string param


我知道你在想Groovy是怎么实现的，让我来告诉你。

首先，Groovy有类型猜测系统（Type inference），编译期会根据类型猜测系统的提示进行方法选择。
其次，所有Groovy的对象都有元类信息(metaClass)，运行期通过把所有方法的调用分发至MOP（Meta Object Protocol，元对象协议）上来进行动态地方法选择。简单来说，有点像运行期做了个AOP，然后反射去拿各种对象信息，再去调用正确的方法。（不负责非正确比喻，请无视。当然Groovy肯定不是用AOP和反射来实现的，并且它的做法比反射理论上来说更高效）

为什么Groovy能做到这些？因为它和Java是异源同宗的，虽然两者最终编译结果都是能够在JVM上运行的class字节码，但是groovy并非先编译成Java再编译成class字节码的，所以它可以越过Java的编译器，做一些Java做不到但是JVM能做的事情。

譬如说像下面这种会让Java程序员抓狂的事情
{% highlight groovy %}
def something = new Object()
something.metaClass.helloWorld = { println "Hello World from an Object!" }
something.helloWorld()
{% endhighlight %}

输出

    Hello World from an Object!

你看！一个方法凭空就加到Object对象上惹！


### 函数化编程

作为一门现代化编程语言，不支持函数化编程是不行的。Groovy支持函数化编程的两大特性：

1. 方法（闭包）可以作为头等公民来传递。
2. 支持不可变对象(immutable)和等值(equality)而非等同(identity)比较

我们还是来看代码吧
{% highlight groovy %}
def someClosure = { println "This is a closure and the parameter is $it" } // 闭包，只有一个参数默认it，字符串中$it将会被替换成它的值。
def callClosureMethod(Closure callback, int it) { // 这个方法调用闭包
  callback(it) // 还可以使用callback.call(it)来调用
}
callClosureMethod(someClosure, 47)
{% endhighlight %}

这还不是最赞的地方，还有更赞的
{% highlight groovy %}
// 停留3秒钟后打印bye!
Thread.start { sleep 3000; println "bye!" } // 还记得Java中的Thread吗？这个就是它，后面的花括号是闭包。
{% endhighlight %}

你看这个闭包没有继承Runnable也没有实现run方法！如果将这样的闭包用在像addListener这样的方法上将会有多爽快！是的，你的确可以这样用！

当然，除了闭包，方法也可以传递，但是由于Java的限制，你得用`&`创建一个方法闭包：
{% highlight groovy %}
def tellMe(int v) {
  println "The value of v is $v"
}

def runClosure(def c) {
  c(47)
}

def methodClosure = this.&tellMe
runClosure(methodClosure)
{% endhighlight %}

说到闭包就不得不谈到闭包的作用域scope，在所有函数式编程语言总，这是一个很高级的话题，一旦谈到这个问题，不外乎难倒面试/教做人/欺负新人/装逼的。为去歧义，明确说一下，这里的“闭包的作用域”指的不是闭包本身的作用域，而是指闭包代码块内各个变量的作用域。

在Groovy中，闭包的作用域是可以通过更改delegate来改变的。闭包代码块内，所有变量的引用，都是通过变量前加前缀`delegate.`来解析的，而delegate本身所指向的对象是可以改变的，默认指向的是闭包的所有者(owner)，即定义闭包的对象。
并且，“变量前加前缀`delegate.`”这个操作，即闭包内变量的解析，也是可以通过为闭包设置`resolveStrategy`属性来改变的。可用的`resolveStrategy`有`OWNER_ONLY`, `OWNER_FIRST`(默认), `DELEGATE_ONLY`, `DELEGATE_FIRST`, `SELF_ONLY`。这样Groovy闭包内作用域就变得非常灵活可变了。

// TODO 不可变对象

### 编译期元编程与语义树变换

// TODO


<a id="id1"/>注1: 参考《深入理解Java虚拟机-JVM高级特性与最佳实践》，周志明著，2011年9月版，8.3.2.分派，209页。
